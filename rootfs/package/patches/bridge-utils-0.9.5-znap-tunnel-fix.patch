diff --git a/Makefile b/Makefile
index 8f24b9d..ef49963 100644
--- a/Makefile
+++ b/Makefile
@@ -1,3 +1,27 @@
+ifeq ($(SLINK),1)
+S_LINK="SLINK=1"
+else
+S_LINK=
+endif
+
+ifeq ($(MD),615-96b)
+GUEST_ZONE="GUEST_ZONE=1"
+else
+ifeq ($(MD),618-96b)
+GUEST_ZONE="GUEST_ZONE=1"
+else
+ifeq ($(MD),615-96c)
+GUEST_ZONE="GUEST_ZONE=1"
+else
+ifeq ($(MD),618-96c)
+GUEST_ZONE="GUEST_ZONE=1"
+endif
+endif
+endif
+endif
+#export HARD_FLOAT=-mhard-float
+
+
 all:				brctl/brctl brctl/brctld misc/bidi
 
 clean:
@@ -6,13 +30,21 @@ clean:
 				make -C misc clean
 
 brctl/brctl:			brctl/brctl.c brctl/brctl.h brctl/brctl_cmd.c brctl/brctl_disp.c libbridge/libbridge.a libbridge/libbridge.h
-				make -C brctl
+				make -C brctl $(S_LINK) $(GUEST_ZONE)
 
 brctl/brctld:			brctl/brctld.c brctl/brctl.h brctl/brctl_cmd.c brctl/brctl_disp.c libbridge/libbridge.a libbridge/libbridge.h
 				make -C brctl
 
 libbridge/libbridge.a:		libbridge/if_index.c libbridge/libbridge.h libbridge/libbridge_compat.c libbridge/libbridge_devif.c libbridge/libbridge_if.c libbridge/libbridge_init.c libbridge/libbridge_misc.c libbridge/libbridge_private.h
-				make -C libbridge
+				make -C libbridge $(S_LINK) $(GUEST_ZONE)
 
 misc/bidi:			misc/bidi.c
 				make -C misc
+
+install:
+				mkdir -p $(PREFIX)/{sbin,include,lib}
+				install -m 775 brctl/brctl $(PREFIX)/sbin
+				install libbridge/libbridge.h brctl/brctl.h $(PREFIX)/include
+				install libbridge/libbridge.a $(PREFIX)/lib
+
+
diff --git a/brctl/Makefile b/brctl/Makefile
index e34570b..b31458e 100644
--- a/brctl/Makefile
+++ b/brctl/Makefile
@@ -1,10 +1,23 @@
+CC=$(CROSS)gcc
+CFLAGS = -Wall -c -Os $(HARD_FLOAT)
+LDFLAGS = -s -Wall 
+
+ifeq ($(SLINK),1)
+CFLAGS  += -ffunction-sections -fdata-sections
+LDFLAGS += --static -Wl,--gc-sections
+endif
+
+ifeq ($(GUEST_ZONE),1)
+CFLAGS  += -DGUEST_ZONE
+endif
+
 all:			brctl brctld
 
 brctl:			brctl.o brctl_cmd.o brctl_disp.o ../libbridge/libbridge.a
-			gcc -Wall -g -o brctl brctl.o brctl_cmd.o brctl_disp.o ../libbridge/libbridge.a
+			$(CC) $(LDFLAGS) -o brctl brctl.o brctl_cmd.o brctl_disp.o ../libbridge/libbridge.a
 
 brctld:			brctld.o brctl_cmd.o brctl_disp.o ../libbridge/libbridge.a
-			gcc -Wall -g -o brctld brctld.o brctl_cmd.o brctl_disp.o ../libbridge/libbridge.a
+			$(CC) $(LDFLAGS) -o brctld brctld.o brctl_cmd.o brctl_disp.o ../libbridge/libbridge.a
 
 clean:
 			rm -f *.o
@@ -13,13 +26,13 @@ clean:
 			rm -f core
 
 brctl.o:		brctl.c brctl.h
-			gcc -I../libbridge -Wall -c -g -o brctl.o brctl.c
+			$(CC) -s -I../libbridge $(CFLAGS) -o brctl.o brctl.c
 
 brctld.o:		brctld.c brctl.h
-			gcc -I../libbridge -Wall -c -g -o brctld.o brctld.c
+			$(CC) -s -I../libbridge $(CFLAGS) -o brctld.o brctld.c
 
 brctl_cmd.o:		brctl_cmd.c brctl.h
-			gcc -I../libbridge -Wall -c -g -o brctl_cmd.o brctl_cmd.c
+			$(CC) -s -I../libbridge $(CFLAGS) -o brctl_cmd.o brctl_cmd.c
 
 brctl_disp.o:		brctl_disp.c brctl.h
-			gcc -I../libbridge -Wall -c -g -o brctl_disp.o brctl_disp.c
+			$(CC) -s -I../libbridge $(CFLAGS) -o brctl_disp.o brctl_disp.c
diff --git a/brctl/brctl.c b/brctl/brctl.c
index f4d137a..38a4546 100644
--- a/brctl/brctl.c
+++ b/brctl/brctl.c
@@ -42,7 +42,31 @@ char *help_message =
 "\tsetmaxage\t<bridge> <time>\t\tset max message age\n"
 "\tsetpathcost\t<bridge> <port> <cost>\tset path cost\n"
 "\tsetportprio\t<bridge> <port> <prio>\tset port priority\n"
-"\tstp\t\t<bridge> <state>\tturn stp on/off\n";
+"\tstp\t\t<bridge> <state>\tturn stp on/off\n"
+"\tmeshsignaloff\t\tdisable signal to pathselection daemon(mesh)\n"
+#ifdef MULTICAST_FILTER
+"\n"
+"\tclrfltrport\t<bridge>\t\tclear multicast filter\n"
+"\tsetfltrport\t<bridge> <port>\t\tset port number of filter\n"
+#endif
+#ifdef MULTICAST_BWCTRL
+"\n"
+"\tsetbwctrl\t<bridge> <port> <bdwh>\tset multicast bandwidth (kbps)\n"
+#endif
+#ifdef RTL_BRIDGE_MAC_CLONE
+"\n"
+"\tclone\t\t<bridge> <ptFr> <ptTo>\tturn MAC clone on\n"
+#endif
+#ifdef GUEST_ZONE
+"\tsetzone\t\t<bridge> <device> <val>\tset zone type (0: host, 1: guest) for interface\n"
+"\tsetzoneisolate\t<bridge> <value>\tset zone isolation (0: no, 1: yes)\n"
+"\tsetguestisolate\t<bridge> <value>\tset guest isolation (0: no, 1: yes)\n"
+"\tchkguestmac\t<bridge> <verb> <mac>\tcheck if mac addrs of client is come from guest zone\n"
+"\tsetlockclient\t<bridge> <mac>\t\tset mac addrs of locked client list\n"
+"\tshowguestinfo\t<bridge>\t\tshow zone and locked client info\n"
+#endif
+"\tsetstatic\t<bridge> <mac> type(0:no,1:yes)\tturn on/off client mac static state\n"
+;
 
 void help()
 {
diff --git a/brctl/brctl_cmd.c b/brctl/brctl_cmd.c
index 264a27d..a96a27f 100644
--- a/brctl/brctl_cmd.c
+++ b/brctl/brctl_cmd.c
@@ -229,6 +229,11 @@ void br_cmd_stp(struct bridge *br, char *arg0, char *arg1)
 	br_set_stp_state(br, stp);
 }
 
+void br_cmd_meshsignaloff(struct bridge *br, char *arg0, char *arg1)
+{
+	br_turnoff_signal_pathsel(br);
+}
+
 void br_cmd_showstp(struct bridge *br, char *arg0, char *arg1)
 {
 	br_dump_info(br);
@@ -286,8 +291,11 @@ void br_cmd_showmacs(struct bridge *br, char *arg0, char *arg1)
 	while (1) {
 		int i;
 		int num;
-
+#ifdef GUEST_ZONE
+		num = br_read_fdb(br, fdb, offset, 1024, 0);
+#else
 		num = br_read_fdb(br, fdb, offset, 1024);
+#endif
 		if (!num)
 			break;
 
@@ -300,6 +308,179 @@ void br_cmd_showmacs(struct bridge *br, char *arg0, char *arg1)
 	}
 }
 
+#ifdef MULTICAST_FILTER
+void br_cmd_clrfltrport(struct bridge *br, char *arg0, char *arg1)
+{
+	br_set_clrfltr(br);
+}
+
+void br_cmd_setfltrport(struct bridge *br, char *arg0, char *arg1)
+{
+	int port;
+
+	sscanf(arg0, "%i", &port);
+	br_set_fltrport(br, port);
+}
+#endif
+
+#ifdef MULTICAST_BWCTRL
+void br_cmd_setbwctrl(struct bridge *br, char *arg0, char *arg1)
+{
+	int bandwidth;
+	struct port *p;
+
+	if ((p = br_find_port(br, arg0)) == NULL) {
+		fprintf(stderr, "can't find port %s in bridge %s\n", arg0, br->ifname);
+		return;
+	}
+
+	sscanf(arg1, "%i", &bandwidth);
+	br_set_mlticst_bw(p, bandwidth);
+}
+#endif
+
+#ifdef RTL_BRIDGE_MAC_CLONE
+void br_cmd_enable_macclone(struct bridge *br, char *arg0, char *arg1)
+{
+	struct port *p, *target;
+
+	if ((p = br_find_port(br, arg0)) == NULL) {
+		fprintf(stderr, "can't find port %s in bridge %s\n", arg0, br->ifname);
+		return;
+	}
+
+	if ((target = br_find_port(br, arg1)) == NULL) {
+		fprintf(stderr, "can't find port %s in bridge %s\n", arg1, br->ifname);
+		return;
+	}
+
+	br_set_port_enable_macclone(p, target);
+}
+#endif
+
+
+#ifdef GUEST_ZONE
+void br_cmd_set_zone(struct bridge *br, char *arg0, char *arg1)
+{
+	struct port *p;
+	int val;
+	if ((p = br_find_port(br, arg0)) == NULL) {
+		fprintf(stderr, "can't find port %s in bridge %s\n", arg0, br->ifname);
+		return;
+	}
+	sscanf(arg1, "%i", &val);	
+	br_set_port_zone(p, val);
+}
+
+void br_cmd_set_isolation_zone(struct bridge *br, char *arg0, char *arg1)
+{
+	int val;
+	sscanf(arg0, "%i", &val);	
+
+	br_set_isolation_zone(br, val);
+}
+
+void br_cmd_set_isolation_guest(struct bridge *br, char *arg0, char *arg1)
+{
+	int val;
+	sscanf(arg0, "%i", &val);	
+	
+	br_set_isolation_guest(br, val);
+}
+
+void br_cmd_chk_guestmac(struct bridge *br, char *arg0, char *arg1)
+{
+	unsigned char mac[6];
+	unsigned int tmp[6];
+	struct fdb_entry fdb[1024];
+	int offset;
+	int verbose;
+
+	sscanf(arg0, "%i", &verbose);	
+
+	if (sscanf(arg1, "%02x%02x%02x%02x%02x%02x", 
+			&tmp[0], &tmp[1], &tmp[2], &tmp[3], &tmp[4], &tmp[5]) != 6) {
+		fprintf(stderr, "invalid mac address format [xxxxxxxxxxxx]!\n");
+		return;			
+	}
+	mac[0] = (unsigned char)tmp[0];
+	mac[1] = (unsigned char)tmp[1];
+	mac[2] = (unsigned char)tmp[2];
+	mac[3] = (unsigned char)tmp[3];
+	mac[4] = (unsigned char)tmp[4];
+	mac[5] = (unsigned char)tmp[5];
+
+	offset = 0;
+	while (1) {
+		int i;
+		int num;
+		num = br_read_fdb(br, fdb, offset, 1024, 1);
+		if (!num) {
+			break;
+		}
+		
+		for (i=0;i<num;i++) {			
+			if (!memcmp(fdb[i].mac_addr, mac, 6)) {
+				if (verbose)
+					fprintf(stderr, "is guest address!\n");
+				exit(1);
+			}			
+		}
+		offset += num;
+	}
+	if (verbose)
+		fprintf(stderr, "not guest address!\n");	
+}
+
+void br_cmd_set_lockclient(struct bridge *br, char *arg0, char *arg1)
+{
+	unsigned char mac[6];
+	unsigned int tmp[6];
+
+	if (sscanf(arg0, "%02x%02x%02x%02x%02x%02x", 
+			&tmp[0], &tmp[1], &tmp[2], &tmp[3], &tmp[4], &tmp[5]) != 6) {
+		fprintf(stderr, "invalid mac address format [xxxxxxxxxxxx]!\n");
+		return;			
+	}
+	mac[0] = (unsigned char)tmp[0];
+	mac[1] = (unsigned char)tmp[1];
+	mac[2] = (unsigned char)tmp[2];
+	mac[3] = (unsigned char)tmp[3];
+	mac[4] = (unsigned char)tmp[4];
+	mac[5] = (unsigned char)tmp[5];
+
+	br_set_lock_client(br, mac);
+}
+void br_cmd_show_guestinfo(struct bridge *br, char *arg0, char *arg1)
+{
+	br_show_guestinfo(br);
+}
+#endif // GUEST_ZONE
+
+void br_cmd_set_static_client(struct bridge *br, char *arg0, char *arg1)
+{
+	unsigned char mac[6];
+	unsigned int tmp[6];
+	int isstatic = 0;
+	
+	if (!strcmp(arg1, "on") || !strcmp(arg1, "yes") || !strcmp(arg1, "1"))
+		isstatic = 1;
+
+	if (sscanf(arg0, "%02x%02x%02x%02x%02x%02x", 
+			&tmp[0], &tmp[1], &tmp[2], &tmp[3], &tmp[4], &tmp[5]) != 6) {
+		fprintf(stderr, "invalid mac address format [xxxxxxxxxxxx]!\n");
+		return;			
+	}
+	mac[0] = (unsigned char)tmp[0];
+	mac[1] = (unsigned char)tmp[1];
+	mac[2] = (unsigned char)tmp[2];
+	mac[3] = (unsigned char)tmp[3];
+	mac[4] = (unsigned char)tmp[4];
+	mac[5] = (unsigned char)tmp[5];
+
+	br_set_static_client(br, mac, isstatic);
+}
+
 static struct command commands[] = {
 	{0, 1, "addbr", br_cmd_addbr},
 	{1, 1, "addif", br_cmd_addif},
@@ -317,6 +498,32 @@ static struct command commands[] = {
 	{1, 0, "showmacs", br_cmd_showmacs},
 	{1, 0, "showstp", br_cmd_showstp},
 	{1, 1, "stp", br_cmd_stp},
+//#if defined(CONFIG_RTK_MESH) && defined(MESH_DYPORTAL)
+	{0, 0, "meshsignaloff", br_cmd_meshsignaloff},
+//#endif
+
+#ifdef MULTICAST_FILTER
+	{1, 0, "clrfltrport", br_cmd_clrfltrport},
+	{1, 1, "setfltrport", br_cmd_setfltrport},
+#endif
+
+#ifdef MULTICAST_BWCTRL
+	{1, 2, "setbwctrl", br_cmd_setbwctrl},
+#endif
+
+#ifdef RTL_BRIDGE_MAC_CLONE
+	{1, 2, "clone", br_cmd_enable_macclone},
+#endif
+
+#ifdef GUEST_ZONE
+	{1, 2, "setzone", br_cmd_set_zone},	
+	{1, 1, "setzoneisolate", br_cmd_set_isolation_zone},	
+	{1, 1, "setguestisolate", br_cmd_set_isolation_guest},
+	{1, 2, "chkguestmac", br_cmd_chk_guestmac},
+	{1, 1, "setlockclient", br_cmd_set_lockclient},	
+	{1, 0, "showguestinfo", br_cmd_show_guestinfo},	
+#endif
+	{1, 2, "setstatic", br_cmd_set_static_client},	
 };
 
 struct command *br_command_lookup(char *cmd)
diff --git a/brctl/brctld.c b/brctl/brctld.c
index f2b4e45..fbc9a96 100644
--- a/brctl/brctld.c
+++ b/brctl/brctld.c
@@ -192,7 +192,7 @@ int main(int argc, char *argv[])
 	signal(SIGCHLD, sigchild);
 
 	while (1) {
-		int len;
+		socklen_t len;
 		int newsock;
 
 		len = sizeof(addr);
diff --git a/libbridge/Makefile b/libbridge/Makefile
index 375775b..4da0f41 100644
--- a/libbridge/Makefile
+++ b/libbridge/Makefile
@@ -1,5 +1,12 @@
-CC = gcc
-CFLAGS = -Wall -g
+CFLAGS = -Wall -Os $(HARD_FLOAT)
+
+ifeq ($(SLINK),1)
+CFLAGS  += -ffunction-sections -fdata-sections
+endif
+
+ifeq ($(GUEST_ZONE),1)
+CFLAGS  += -DGUEST_ZONE
+endif
 
 all:			libbridge.a
 
diff --git a/libbridge/if_index.c b/libbridge/if_index.c
index 865bd45..33a7f57 100644
--- a/libbridge/if_index.c
+++ b/libbridge/if_index.c
@@ -24,7 +24,6 @@
 #include <net/if.h>
 #include <sys/socket.h>
 #include <sys/ioctl.h>
-#include <bits/libc-lock.h>
 
 /* Try to get a socket to talk to the kernel.  */
 #if defined SIOCGIFINDEX || defined SIOCGIFNAME
@@ -34,36 +33,9 @@ opensock (void)
 {
   /* Cache the last AF that worked, to avoid many redundant calls to
      socket().  */
-  static int sock_af = -1;
-  int fd = -1;
-  __libc_lock_define_initialized (static, lock);
+     int fd ;
 
-  if (sock_af != -1)
-    {
-      fd = __socket (sock_af, SOCK_DGRAM, 0);
-      if (fd != -1)
-        return fd;
-    }
-
-  __libc_lock_lock (lock);
-
-  if (sock_af != -1)
-    fd = __socket (sock_af, SOCK_DGRAM, 0);
-
-  if (fd == -1)
-    {
-      fd = __socket (sock_af = AF_INET6, SOCK_DGRAM, 0);
-      if (fd < 0)
-	fd = __socket (sock_af = AF_INET, SOCK_DGRAM, 0);
-      if (fd < 0)
-	fd = __socket (sock_af = AF_IPX, SOCK_DGRAM, 0);
-      if (fd < 0)
-	fd = __socket (sock_af = AF_AX25, SOCK_DGRAM, 0);
-      if (fd < 0)
-	fd = __socket (sock_af = AF_APPLETALK, SOCK_DGRAM, 0);
-    }
-
-  __libc_lock_unlock (lock);
+     fd = __socket (AF_INET, SOCK_DGRAM, 0);
   return fd;
 }
 #endif
@@ -197,7 +169,7 @@ if_nameindex (void)
 }
 
 char *
-if_indextoname (unsigned int ifindex, char *ifname)
+if_indextoname (unsigned ifindex, char *ifname)
 {
 #ifndef SIOCGIFINDEX
   __set_errno (ENOSYS);
diff --git a/libbridge/libbridge.h b/libbridge/libbridge.h
index a3f96d4..28cedd5 100644
--- a/libbridge/libbridge.h
+++ b/libbridge/libbridge.h
@@ -22,6 +22,15 @@
 #include <net/if.h>
 #include <linux/if_bridge.h>
 
+// interface to set port number of multicast filter
+//#define MULTICAST_FILTER
+
+// interface to set multicast bandwidth control
+//#define MULTICAST_BWCTRL
+
+// interface to enable MAC clone function
+//#define RTL_BRIDGE_MAC_CLONE
+
 struct bridge;
 struct bridge_info;
 struct fdb_entry;
@@ -120,13 +129,38 @@ int br_set_bridge_max_age(struct bridge *br, struct timeval *tv);
 int br_set_ageing_time(struct bridge *br, struct timeval *tv);
 int br_set_gc_interval(struct bridge *br, struct timeval *tv);
 int br_set_stp_state(struct bridge *br, int stp_state);
+void br_cmd_meshsignaloff(struct bridge *, char *arg0, char *arg1);
 int br_set_bridge_priority(struct bridge *br, int bridge_priority);
 int br_set_port_priority(struct port *p, int port_priority);
 int br_set_path_cost(struct port *p, int path_cost);
+int br_set_static_client(struct bridge *br, unsigned char *mac, int isstatic );
+int br_turnoff_signal_pathsel(struct bridge *br);
+#ifdef GUEST_ZONE
+int br_read_fdb(struct bridge *br, struct fdb_entry *fdbs, int offset, int num, int for_guest);
+#else
 int br_read_fdb(struct bridge *br, struct fdb_entry *fdbs, int offset, int num);
+#endif
+#ifdef MULTICAST_FILTER
+int br_set_clrfltr(struct bridge *br);
+int br_set_fltrport(struct bridge *br, int port);
+#endif
+#ifdef MULTICAST_BWCTRL
+int br_set_mlticst_bw(struct port *p, int bandwidth);
+#endif
+#ifdef RTL_BRIDGE_MAC_CLONE
+int br_set_port_enable_macclone(struct port *p, struct port *target);
+#endif
+#ifdef GUEST_ZONE
+int br_set_port_zone(struct port *p, int zone_value);
+int br_set_isolation_zone(struct bridge *br, int val);
+int br_set_isolation_guest(struct bridge *br, int val);
+int br_set_lock_client(struct bridge *br, unsigned char *mac);
+int br_show_guestinfo(struct bridge *br);
+#endif
 
 /* libc5 combatability */
-char *if_indextoname(unsigned int __ifindex, char *__ifname);
+char *if_indextoname(unsigned __ifindex, char *__ifname);
 unsigned int if_nametoindex(const char *__ifname);
-
+char *br_found_bridge_by_port(char *portname);
+int br_get_bridges_lists(char *brname);
 #endif
diff --git a/libbridge/libbridge_devif.c b/libbridge/libbridge_devif.c
index 936fa9a..303db3b 100644
--- a/libbridge/libbridge_devif.c
+++ b/libbridge/libbridge_devif.c
@@ -146,6 +146,18 @@ int br_set_stp_state(struct bridge *br, int stp_state)
 	return 0;
 }
 
+int br_turnoff_signal_pathsel(struct bridge *br)
+{
+	unsigned long args[3];
+
+        args[0] = 111;	//should br BRCTL_SET_BRIDGE_STP_STATE
+        args[1] = 0;
+        args[2] = 0;
+
+        return ioctl(br_socket_fd, SIOCGIFBR, args);
+        //return 0;
+}
+
 int br_set_bridge_priority(struct bridge *br, int bridge_priority)
 {
 	if (br_device_ioctl(br, BRCTL_SET_BRIDGE_PRIORITY, bridge_priority,
@@ -181,18 +193,131 @@ void __copy_fdb(struct fdb_entry *ent, struct __fdb_entry *f)
 	__jiffies_to_tv(&ent->ageing_timer_value, f->ageing_timer_value);
 }
 
+#ifdef GUEST_ZONE
+int br_read_fdb(struct bridge *br, struct fdb_entry *fdbs, int offset, int num, int for_guest)
+#else
 int br_read_fdb(struct bridge *br, struct fdb_entry *fdbs, int offset, int num)
+#endif
 {
 	struct __fdb_entry f[num];
 	int i;
 	int numread;
 
+#ifdef GUEST_ZONE
+	unsigned long id;
+	if (for_guest)
+		id = 110;
+	else
+		id = BRCTL_GET_FDB_ENTRIES;
+	if ((numread = br_device_ioctl(br, id,
+				       (unsigned long)f, num, offset)) < 0)
+		return errno;
+#else
 	if ((numread = br_device_ioctl(br, BRCTL_GET_FDB_ENTRIES,
 				       (unsigned long)f, num, offset)) < 0)
 		return errno;
+#endif
 
 	for (i=0;i<numread;i++)
 		__copy_fdb(fdbs+i, f+i);
 
 	return numread;
 }
+
+#ifdef MULTICAST_FILTER
+int br_set_clrfltr(struct bridge *br)
+{
+	if (br_device_ioctl(br, 101, 0,
+			    0, 0) < 0)
+		return errno;
+
+	return 0;
+}
+
+int br_set_fltrport(struct bridge *br, int port)
+{
+	if (br_device_ioctl(br, 102, port,
+			    0, 0) < 0)
+		return errno;
+
+	return 0;
+}
+#endif
+
+#ifdef MULTICAST_BWCTRL
+int br_set_mlticst_bw(struct port *p, int bandwidth)
+{
+	if (br_device_ioctl(p->parent, 103, p->index,
+			    bandwidth, 0) < 0)
+		return errno;
+
+	return 0;
+}
+#endif
+
+#ifdef RTL_BRIDGE_MAC_CLONE
+int br_set_port_enable_macclone(struct port *p, struct port *target)
+{
+	if (br_device_ioctl(p->parent, 104, p->index,
+			    target->index, 0) < 0)
+		return errno;
+
+	return 0;
+}
+#endif
+
+#ifdef GUEST_ZONE
+int br_set_port_zone(struct port *p, int zone_value)
+{
+	if (br_device_ioctl(p->parent, 105, p->index,
+			    zone_value, 0) < 0) 
+		return errno;
+
+	return 0;
+}
+
+int br_set_isolation_zone(struct bridge *br, int val)
+{
+	if (br_device_ioctl(br, 106, val,
+			    0, 0) < 0)
+		return errno;
+
+	return 0;
+}
+
+int br_set_isolation_guest(struct bridge *br, int val)
+{
+	if (br_device_ioctl(br, 107, val,
+			    0, 0) < 0)
+		return errno;
+
+	return 0;
+}
+
+int br_set_lock_client(struct bridge *br, unsigned char *mac)
+{
+	if (br_device_ioctl(br, 108, (unsigned long)mac,
+			    0, 0) < 0)
+		return errno;
+
+	return 0;
+}
+int br_show_guestinfo(struct bridge *br)
+{
+	if (br_device_ioctl(br, 109, 0,
+			    0, 0) < 0)
+		return errno;
+
+	return 0;
+}
+
+#endif // GUEST_ZONE
+int br_set_static_client(struct bridge *br, unsigned char *mac, int isstatic )
+{
+	if (br_device_ioctl(br, 110, (unsigned long)mac, (unsigned long)isstatic, 0) < 0)
+		return errno;
+
+	return 0;
+}
+
+
diff --git a/libbridge/libbridge_init.c b/libbridge/libbridge_init.c
index 114a099..25f3998 100644
--- a/libbridge/libbridge_init.c
+++ b/libbridge/libbridge_init.c
@@ -167,6 +167,13 @@ int br_make_bridge_list()
 		struct bridge *br;
 
 		br = malloc(sizeof(struct bridge));
+		/* BEGIN: Added by 李华, 2013/3/25 增加对malloc返回值判断*/
+		if(NULL == br)
+		{
+			return -1;
+		}
+		/* END:   Added by 李华, 2013/3/25   PN: */
+
 		memset(br, 0, sizeof(struct bridge));
 		br->ifindex = ifindices[i];
 		br->firstport = NULL;
diff --git a/libbridge/libbridge_misc.c b/libbridge/libbridge_misc.c
index 31e054e..b467158 100644
--- a/libbridge/libbridge_misc.c
+++ b/libbridge/libbridge_misc.c
@@ -1,3 +1,8 @@
+/*********************************************************************
+ *修改记录:2012-09-12,谢少军
+ *         BUG#4153,集中转发隧道业务有时会获取不到地址
+************************************************************************/
+
 /*
  * Copyright (C) 2000 Lennert Buytenhek
  *
@@ -58,7 +63,7 @@ struct bridge *br_find_bridge(char *brname)
 
 	b = bridge_list;
 	while (b != NULL) {
-		if (!strcmp(b->ifname, brname))
+		if ((strcmp(b->ifname, brname) == 0) &&(strlen(b->ifname)==strlen(brname)))
 			return b;
 
 		b = b->next;
@@ -69,7 +74,10 @@ struct bridge *br_find_bridge(char *brname)
 
 struct port *br_find_port(struct bridge *br, char *portname)
 {
+	/* 2012-09-12,xieshaojun, if_nametoindex() return unsigned
 	char index;
+	*/
+	unsigned index;
 	struct port *p;
 
 	if (!(index = if_nametoindex(portname)))
@@ -85,3 +93,40 @@ struct port *br_find_port(struct bridge *br, char *portname)
 
 	return NULL;
 }
+
+char *br_found_bridge_by_port(char *portname)
+{
+	struct bridge *b;
+	struct port *p;
+	b = bridge_list;
+	while (b != NULL) {
+
+		p = br_find_port(b, portname);
+		if (p){
+
+			break;
+		}
+		b = b->next;
+	}
+	if(b)
+		return b->ifname;
+	else
+		return NULL;
+}
+
+int br_get_bridges_lists(char *brname)
+{
+	struct bridge *b = br_find_bridge(brname);
+	struct port *p;
+	int num = 0;
+	if(b==NULL)
+		return 0;
+	p = b->firstport;
+	
+	while (p != NULL) {
+		num++;
+		p = p->next;
+	}
+	return num;
+}
+
